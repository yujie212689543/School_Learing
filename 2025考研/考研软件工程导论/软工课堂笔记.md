
### 软件的概念
   *软件是计算机系统的重要组成部分。*
   
   软件是能够完成预定功能和性能并对相应**数据**进行加工的**程序**和描述程序及其操作的**文档**
   ==（它是包括程序、数据及其相关文档的完整集合）==。
   
- **软件=程序+数据+文档
- **程序=算法+数据结构
- **软件≠程序**
### 软件危机的概念
   指在计算机软件的**开发和维护**过程中所遇到的一系列严重问题。
   
### 软件危机主要包括的问题
   1. 如何开发软件以满足对软件日益增长的需求。
   2. 如何维护数量不断膨胀的已有软件。
### 软件工程的概念

   1. 把系统的、规范的、可度量的方法应用于软件的开发、运行和维护的过程，即将工程应用于软件中。
   2. 对1中提到各种方法的研究。

### 软件工程包括两方面
   1. **管理** ——==对人、财、物的合理使用和配置。
   2. **技术** ——==指软件开发中采用的方法、工具和过程。

### 软件工程方法学==三要素：工具、方法、过程


### 软件工程的目标
   在给定成本进度的前提下，开发出具有
   **可修改性、有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可追踪性、可移植性、可互操作性**，并满足用户需求的软件产品。

### 软件工程的原则
   **抽象、信息隐藏、模块化、局部化、一致性、完整性、可验证性。

### 软件生命周期（Lifecycle）
   软件产品从形成概念开始，经过开发、运行和维护，直到退役的全过程称为软件生命周期，包括==软件定义、软件开发、软件运行与维护三部分。

### 什么是软件过程？
   ==为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。

### 什么是软件生命周期模型？（又称软件开发模型/软件过程模型/软件工程范型）
   软件项目从==需求定义直至软件经使用后废弃==为止，跨越整个生命周期的系统开发、运行和维护所实施的全部过程、活动和任务的<font color="#c0504d">*结构框架*</font>。

### **瀑布模型**的优点（适用于开发需求明确）
   1. 可强迫开发人员采用规范的方法。
   2. 严格地规定了每个阶段必须提交的文档==（文档驱动）==。
   3. 要求每个阶段的所有产品都必须经过质量保证小组的仔细验证。

### 瀑布模型的缺点
   1. 无法解决软件需求**不明确、不准确**的问题。
   2. 可能导致最终开发的产品不能真正满足用户需要。

### 螺旋模型的特点（==风险驱动==）
   螺旋模型的每一个周期都包括计划（需求定义）、风险分析、工程实现和评审四个阶段。

### 螺旋模型的优点==适合大型软件开发==
   1. 强调可选方案和约束条件，有利于已有软件的重用，也有助于将软件质量作为软件开发的一个重要目标。
   2. 减少了过多测试（浪费资金）或测试不足（产品故障多）所带来的风险。
   3. 维护是一个周期，与开发并没有本质区别。

### 螺旋模型的缺点
   1. 需要开发人员具有相当丰富的风险评估经验和专门的知识。
   2. 进行风险分析的费用可能较大。

### 可行性研究的目的
   用最小的代价在尽可能短的时间内确定问题是否能够并且值得解决。

 ### 可行性研究包括（5种）
   经济可行性研究、技术可行性研究、法律可行性研究、开发方案的选择性研究、操作可行性的研究。

### 数据流图定义
   它以图形的方式描绘数据在系统中流动（数据流）和处理（数据转换）的过程。

### 数据流图的四种基本符号

![]()
![](D:/ObsidianFile/2025考研/pictures/数据流图符号.jpg)

### 画数据流图步骤  
![](D:\ObsidianFile\2025考研\pictures\画数据流图步骤.jpg)

### 数据字典
用来定义数据流图中的各个成分的具体含义的。

### 数据字典有以下四类条目：
- 数据流
- 数据项
- 数据存储
- 基本加工

### 需求分析的四项任务：
   1. 确定对系统的综合要求
   2. 分析系统的数据要求
   3. 导出系统的逻辑模型
   4. 修正系统开发计划

### 需求分析主要内容（三个重要阶段）：
   - 问题分析
   - 需求描述
   - 需求评审

### 初步需求获取技术：
   1. 访谈与会议
   2. 考察用户软件或其子系统业务流程
   3. 用户和开发人员共同组成联合小组

### 需求分析方法：
   1. 功能分析方法
   2. 结构化分析方法
   3. 信息建模法
   4. 面向对象的分析方法

### 实体关系图
   ==实体关系图是描述系统所有数据对象的组成和属性，描述数据对象之间关系的图形语言。

### 实体关系图的三种基本符号
![](D:\ObsidianFile\2025考研\pictures\实体关系图的三种符号.jpg)
###  绘制实体关系图步骤
   1. 在需求收集的过程中，列出应有软件或业务过程涉及到的所有事物，将其演化成数据对象。
   2. 一次考虑一个对象，定义这个对象和其他对象之间是否存在连接。
   3. 如果存在连接，应创建一个或多个关系。
   4. 对每一个关系，确定其关联类型。
   5. 重复步骤2到步骤4，直到定义了所有关系。
   6. 定义每一个实体的属性。
   7. 复审实体关系图。
   8. 重复步骤1到7，直到数据建模完成。

### 软件设计的两个**阶段**（步骤）：
1. 第一阶段**概要设计**==（总体设计）==：根据需求确定软件和数据的总体框架。
2. 第二阶段**详细设计**==（过程设计）==：将其进一步精化成软件的算法表示和数据结构。

### 抽象
- 认识复杂事物和现象时，抽出事物本质的共同特性，而暂不考虑它们的细节。

### 抽象的步骤：
1. 在最高抽象级别上，用面向问题域的语言叙述问题，概括“问题解”的形式。
2. 不断地具体化，不断地用面向过程的语言描述问题。
3. 在最低的抽象级别上，给出可实现的“问题解”，即程序。

### 信息隐藏的原理：
- 模块应该设计得使其所含信息（过程和数据）对于那些不需要这些信息的模块不可访问。
### 局部化
- 将一些关系密切的软件元素物理的放在彼此靠近。
### 偶合性（也称块间的联系）
- 是对软件系统结构中，各模块间相互联系紧密程度的一种度量。

### 从低到高的耦合类型  
![](D:\ObsidianFile\2025考研\pictures\从低到高的耦合类型.jpg)

### 内聚性（又称块内联系）  
- 指一个模块内部各个元素彼此结合的紧密程度的度量   
### 从高到低的内聚类型  
![](D:\ObsidianFile\2025考研\pictures\从低到高的内聚类型.jpg)
###  软件的深度
   - 指软件结构中模块的层数。
### 软件的宽度
   - 指软件结构内同一层的模块总数的最大值（跨度）。

### 模块的“扇出率”
   - 该模块直接控制的其他模块数（直属下级）。

### 模块的“扇入率”
   - 能直接控制该模块的模块数（有多少上层模块调用它）。

### 用SD方法将数据流图转化为软件结构的五个步骤：
   1. 确定信息流的类型。
   2. 划定流界。
   3. 将数据流图映射为程序结构。
   4. 提取层次控制结构。
   5. 通过设计复审和启发式策略精化结构。

### 信息流的两种类型
   1. 变换流
   2. 事务流

### 变换分析的步骤
   1. 复审基本系统模型
   2. 复审和精化软件数据流图
   3. 确定DFD为变换流还是事务流
   4. 划定输入流和输出流边界，孤立变换中心
   5. 执行“一级分解”，导出具有三个层次的程序结构
   6. 执行“二级分解”
   7. 采用启发式设计策略，精化所有程序雏形，改良软件质量

### 事务分析法的七个步骤
   1. 复审基本系统类型
   2. 复审并精化软件数据流图
   3. 确定数据流图的特性
   4. 找出数条动作路径的公共源头，即为事务中心，确定由事务中心发出的每一动作路径的数据流特性
   5. 把数据流图映射为事务处理型的程序结构
   6. 分解并精化事务结构以及每条动作路径所对应的结构
   7. 使用启发式设计策略，精化所得程序结构雏形，改良软件质量
### 过程设计的主要任务：
   1. 为每个模块确定采用的算法。
   2. 确定每一个模块使用的数据结构。
   3. 确定模块接口的细节。
   4. 为每一个模块设计出一组测试用例。

### 结构化程序设计定义：
   - 采用自顶向下逐步求精的设计方法和单入口单出口的控制构件。

### 用户界面应具备的特性：
   1. 可使用性。
   2. 灵活性。
   3. 复杂性。
   4. 可靠性。
###  四代人机界面的风格：
   - 最早是命令和询问方式。
   -  第二代界面是简单的菜单式。
   -  第三代界面是面向窗口的点选界面。
   -  第四代界面使用户可同时执行多个任务。

### 人机界面设计过程：
   1. 创建系统功能的外部模型。
   2. 确定为完成此系统功能人和计算机应分别完成的任务。
   3. 考虑界面设计中的典型问题。
   4. 借助CASE工具构造界面原型。
   5. 真正实现设计模型。
   6. 评估界面质量。

### 人机界面设计问题：
   1. 系统响应时间。
   2. 用户帮助信息。
   3. 出错信息处理。
   4. 命令交互。
### 五种基本控制结构在盒图中的表示（N-S图）
![](D:\ObsidianFile\2025考研\pictures\五种基本结构在盒图中表示.jpg)
### 盒图的特点（顺序、选择、循环结构）：
1. 盒图的功能域（指分支和循环结构的边界）比流程图更清晰，控制不能随意转移。
2. 数据的作用域容易确定。
3. 容易表现嵌套关系和模块的层次结构。

### 判定表的组成：
   - 所有条件
   - 所有动作
   - 条件组合及对应动作

### 产生判定表的步骤：
   1. 列出与该过程（或模块）有关的动作。
   2. 列出所有独立条件。
   3. 根据问题处理描述，把条件组合与特定的动作联系起来，删去无意义的条件组合。
   4. 定义处理规则，即指明条件下做什么动作。

### 程序结构复杂性度量：
**巡回秩数V(G)=e-n+2
	- e为结构图的边数
	- n为结构图的节点数


### 编码
- 把软件设计翻译成计算机可以理解的形式 ——用某种程序设计语言书写的程序。

### 影响编码质量的因素：包括编程语言、编程准则（先空着）。

### 程序设计语言的分类：
   1. 第一代语言：指机器语言和汇编语言。
   2. 第二代语言：如Fortran、Cobol、Basic语言等。
   3. 第三代语言：通向高级语言、面向对象的语言和专用语言。
   4. 第四代语言：使用最广的是数据库查询语言。 

### 好的编程风格应遵守的准则：(6个)
- 节俭化
- 模块化
- 简单化
- 结构化
- 文档化
- 格式化  

### 测试的定义：测试是为了发现错误而执行的程序的过程。
### 测试用例：把==测试数据和预期的输出结果==称为测试用例。
### 黑盒测试（注重功能）：
- 已知产品应该具有的功能，通过测试检验每个功能是否都能正常使用。
### 白盒测试（注重结构）：
- 已知产品内部工作过程，通过测试检验产品内部动作是否按照产品规格说明的规定正常进行。


### 基本路径测试的步骤（**白盒测试**）：
1. 根据程序的逻辑结构画出流程图。
2. 根据流程图画出流图。
3. 确定复杂性度量 V(G)。
4. 确定基本路径的集合。
5. 为每条基本路径设计测试用例。  

### 等价分类法的步骤：
   1. 划分等价类。
   2. 设计有效等价类需要的测试用例。
   3. 为每一个*无效等价类*至少设计一个测试用例。

### 软件测试的四个步骤（**使用白盒测试**）：
   1. 单元测试。
   2. 集成测试。
   3. 确认测试。
   4. 系统测试。

### 非渐增式测试方法：
- 先分别测试每一个模块，再把所有模块按设计要求放在一起结合成所需要的程序。

### 渐增式测试方法：
- 把下一个要测试的模块同已经测试好的那些模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试。  

### 自顶向下集成步骤：
1. 以主控模块作为测试驱动模块，将主控模块进行单元测试时引入的所有桩模块用实际模块替代。
2. 依据所选的集成策略（深度优先或广度优先），每次只替换一个桩模块。
3. 每集成一个模块立即测试一遍。
4. 只有每组测试完成后，才着手替换下一个桩模块。
5. 为避免引入新错误，需不断进行回归测试（即全部或部分的重复已做过的测试）。

### α测试
- 指软件开发公司内部人员模拟各类用户行为对即将面世的软件产品（指称α版本）进行测试，试图发现错误并修正。

### β测试
- 是指软件开发公司组织各方面的典型用户，在日常工作中的实际使用β版本，并要求用户报告异常情况，提出批评意见。

### 软件维护
- 在软件已经交付使用之后，为了改正错误或满足新需要而修改软件的过程。

### 维护的类型（4种）：
1. 改正性维护。
2. 适应性维护。
3. 扩展与完善性维护。
4. 预防性维护。

### 改正性维护：诊断和改正错误的过程。

### 适应性维护：为适应环境的变化而修改软件的活动。

### 扩充与完善性维护：是根据用户在使用过程中提出的一些建设性意见而进行的维护活动。

### 预防性维护：为了提高软件的可维护性，可靠性等，为以后进一步改进软件打下良好基础。

### 维护工作量的模型
![](D:\ObsidianFile\2025考研\pictures\维护工作量的模型.jpg)
### 修改程序的副作用
- 是指因修改软件而造成的错误或其他不希望发生的情况。

### 副作用种类包括：
- 修改代码的副作用。
- 修改数据的副作用。
- 修改状态的副作用。  

### 回归测试
- 是先对修改部分进行测试，然后隔离修改部分，最后再把它们集成起来进行测试。

###  软件可维护性
- 是指修正软件系统出现的错误和缺陷，以及为满足新的要求进行测试修改、扩充或压缩的容易程度。
### 决定软件可维护性的因素包括：
1. 可理解性。
2. 可测试性。
3. 可修改性。
4. 可移植性。
5. 可重用性。

### 用户文档
- 主要描述系统功能和使用方法，并不关心这些功能是如何实现的。

### 系统文档
- 描述系统设计、实现和测试等方面的内容。
###  用户文档的内容包括：
1. 功能描述。
2. 安装文档。
3. 使用手册。
4. 参考手册。
5. 操作员指南（如果需要系统操作员的话）。  
### 传统软件工程的缺点
- 不太适应规模大、特别复杂的项目。
- 难以解决软件重用的问题。
- 难以适应需求的变化。
- 难以彻底解决维护问题。

### 面向对象软件工程采用的思想和准则
- 抽象
- 分类
- 继承
- 聚合
- 封装

### 面向对象方法学的优点
- 与人类习惯的思维方式一致。
- 稳定性好。
- 可重用性好。
- 较易开发大型软件产品。
- 可维护性好。

###  对象
- 对象是现实世界中个体或事物的抽象表示，是其属性和操作的封装。

### 5. 类
- 类表示某些对象在属性和操作方面的共同特征。

### 6. 继承
- 继承表示类之间的内在联系以及对属性和操作的共享。

### 7. 继承的特点
- 子类可以沿用父类的某些特征，子类也可以具有自己独有的属性和操作。

### 8. ==面向对象=对象+继承+聚集+消息。  

## UML共定义10种视图。

### **用例图**
- 从用户的角度描述系统的功能，并指出功能执行者。  
### 2. 用例图的组成符号：
1. **系统**：由一个矩形表示，上面标注系统名称，内部可包含一个或多个用例。
2. **用例**：由一个椭圆形表示，其中标上用例的名称。
3. **角色（参与者）**：角色用一个人形的符号表示。
4. **关联**：角色或用例之间或用例和用例之间的关联线表示。  
![](D:\ObsidianFile\2025考研\pictures\用例图的组成符号.jpg)
### 3. 用例模型的构成：

- **执行者（参与者）**
- **用例**
- **用例与执行者之间的关系**
- **用例与用例之间的关系**
- **系统**

### 4. 行为图：

行为图包括以下类型：
1. **交互图**：分为*顺序图和协作图。
2. **状态图**
3. **活动图**

### 5. 构件图的作用：

- 用于理解和分析软件各部分之间的相互影响程度。

### 6. 部署图：

- 描述软件系统运行环境的硬件及网络的物理体系结构。

### 迭代的渐进式开发过程：

- ==四个阶段：初启，细化，构造和移交

### 在细化阶段可能需要使用的UML语言机制：
- 用例及用例图：描述用户需求。
- 类图：表示领域概念模型。
- 活动图：表示业务流程处理。
- 包图：表示系统高层结构。
- 交互图：表示用例内部实现过程等。  

### 基于UML的需求分析步骤：

1. **利用用例及用例图表示需求**：
2. **利用包图及类图表示目标软件系统的总体框架结构**：
### 场景：

- 场景是用户与系统进行交互的一组具体的动作。**（场景是用例的实例，用例是某类场景的共同抽象）。   

### **主事件流**：
   - 表示正常情况下执行者与系统之间的信息交互及动作序列。

### **辅事件流**：
   - 辅事件流表示特殊情况或异常情况下的信息交互及动作序列。

### **UML类之间的关系**：
   - **继承（Inheritance）**。
   - **聚集（Aggregation）**
   - **关联（Association）**
   - **依赖（Dependency）**  
### **面向对象的软件设计过程**
   1. 设计用例实现方案
   2. 设计技术支撑方案
   3. 设计用户界面
   4. 精化设计模型

### **设计用例实现方案的步骤**
   1. 提取边界类、实体类、控制类
   2. 构造交互图
   3. 根据交互图精化类图
###  **顺序图**
- 描述对象之间传递信息的时间顺序，用来描述用例中的行为顺序。
###  **协作图**
- 用于描述相互合作的对象间的交互关系和链接关系。
### **软件项目管理**
- 软件项目管理旨在通过合理的组织和利用一切可以利用的资源，按照计划的成本和进度，完成计划的目标，以确保软件项目能够按照预定的成本、进度、质量顺利完成。

###  **风险分析** 
- 风险标识、风险估算、风险评价、风险管理。

### **生产率用代码行数度量**
- ==Pl=L/E
	-  L——软件项目代理行
	- E——软件项目工作量。

### **每行代码平均成本**：
- Cl=S/L，
	- S——软件项目总开销。

### **文档与代码比**：
- Dl=Pd/L，
	- Pd——软件项目文档页数。

### **代码出错率**：
- EQR1=Ne/L
	- 其中Ne指软件项目中的错误数。

### **功能点技术基本原理**：
![](D:\ObsidianFile\2025考研\pictures\功能点技术基本原理.jpg)


--------
![](D:\ObsidianFile\2025考研\pictures\家庭保安系统.JPEG)

![](D:\ObsidianFile\2025考研\pictures\银行计算机储蓄系统.JPEG)

![](D:\ObsidianFile\2025考研\pictures\安全管理系统.JPEG)

