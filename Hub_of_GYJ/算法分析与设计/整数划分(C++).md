### 思想  
<mark style="background: #BBFABBA6;">假设函数f(n,m),n为要整数划分的数，m为划分中出现的最大加数</mark>
推出递归关系
1. <font color="#f79646">f(1,m)=1，m>=1</font>
	当n=1时，不论m的值为多少(m > 0)，只有一种划分即一个1。这很好理解，只要m选择比1大的数都会大于n
2. <font color="#f79646">f(n,1)=1，n>=1</font>
	当m = 1 时，不论n的值为多少(m > 0 )，只有一种划分即n个1。这也好理解，最大的加数为1，只能n个1相加才能等于n。
3. <font color="#f79646">f(n,m)=f(n,n)，m>=n</font>
	最大加数m是不能超过整数划分的n的，因此只能更改最大整数m为整数划分的n。例如：f(3,5)=f(3,3)
4. <font color="#f79646">f(n,n)=1+f(n,n-1)</font>
	例如：f(6,6)=1+f(6,5)
5. <font color="#f79646">f(n,m)=f(n,m-1)+f(n-m,m),n>m>1</font>
例如：f(6,4)=f(6,3)+f(2,4) 
                  =f(6,3)+f(2,2) 
                   
| f(6,4)=9                                                          | f(6,3)=7                                                | f(2,2)=2  |
| ----------------------------------------------------------------- | ------------------------------------------------------- | --------- |
| 4+2,4+1+1 3+3,3+2+1,3+1+1+1 2+2+2，2+2+1+1，2+1+1+1+1 1+1+1+1+1+1 | 3+3,3+2+1,3+1+1+1 2+2+2，2+2+1+1，2+1+1+1+1 1+1+1+1+1+1 | 4+2,4+1+1 |
**我们只需要考虑次数，而不需考虑真正的划分加法序列，因此以总次数为中心**
![](Pictures/整数划分公式.jpg)


*问题描述*：将正整数n表示成一系列正整数之和。 n = n1 + n2 + …… + nk，其中n1≥n2≥……≥nk≥1，k≥1 正整数这种表示称为正整数n的划分。正整数n的不同划分个数称为正整数n的划分数，记为p(n)。  

```
6 
5+1 
4+2,4+1+1 
3+3,3+2+1,3+1+1+1 
2+2+2，2+2+1+1，2+1+1+1+1 
1+1+1+1+1+1

输入形式：正整数n
输出形式：n的划分数
样例输入：6
样例输出：11
```  

```Cpp
#include <iostream>
using namespace std;
int partition(int n, int m)
{
    if (n == 1, m == 1)
    {
        return 1;
    }
    else if (n < m)
    {
        return partition(n, n);
    }
    else if (n == m)
    {
        return 1 + partition(n, n - 1);
    }
    else if (n > m)
    {
        return partition(n, m - 1) + partition(n - m, m);
    }
}
int main()
{
    int n;
    cin >> n;
    cout << partition(n, n) << endl;
}
```